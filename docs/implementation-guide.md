# Identity Protocol - Implementation Guide

## Overview

This guide demonstrates how to implement the Identity Protocol metadata standards in real-world scenarios, focusing on practical examples and best practices.

## 1. Creating an Identity Document

### Basic Identity Creation
```typescript
import { 
  IdentityDocument, 
  IdentityMetadata, 
  IdentityPreferences,
  generateTimestamp,
  generateUniqueId,
  PROTOCOL_VERSION,
  CONTEXT_URL,
  DEFAULT_RECOVERY_THRESHOLD,
  MAX_CUSTODIANS
} from '../types/metadata-standards';

const createIdentityDocument = (
  username: string,
  displayName?: string,
  email?: string
): IdentityDocument => {
  const now = generateTimestamp();
  const id = generateUniqueId();
  
  const preferences: IdentityPreferences = {
    privacy: "high",
    sharing: "selective",
    notifications: true,
    backup: true,
    recoveryThreshold: DEFAULT_RECOVERY_THRESHOLD,
    maxCustodians: MAX_CUSTODIANS
  };

  const metadata: IdentityMetadata = {
    username,
    displayName,
    email,
    preferences,
    customFields: {}
  };

  return {
    "@context": CONTEXT_URL,
    id,
    createdAt: now,
    updatedAt: now,
    status: "active",
    metadata,
    custodians: [],
    recoveryConfig: {
      threshold: DEFAULT_RECOVERY_THRESHOLD,
      totalCustodians: 0,
      recoveryKey: "", // Will be generated later
      createdAt: now,
      updatedAt: now,
      isReady: false
    },
    deviceSync: {
      identityId: id,
      devices: [],
      syncSettings: {
        autoSync: true,
        syncInterval: 30,
        encryptInTransit: true,
        allowCrossDeviceAuth: true,
        maxDevices: 5
      },
      lastSyncTimestamp: now
    },
    qrCodeData: {
      lastGenerated: now,
      activeCodes: []
    },
    deepLinkHandling: {
      supportedActions: ["custodian-invitation", "device-sync"],
      lastProcessed: now
    }
  };
};
```

## 2. Adding Custodians

### Custodian Invitation Process
```typescript
import { 
  RecoveryCustodian, 
  CustodianMetadata,
  validateEmail,
  validatePhone,
  generateExpirationTime,
  QR_CODE_EXPIRATION_HOURS
} from '../types/metadata-standards';

const addCustodian = (
  identity: IdentityDocument,
  name: string,
  contactType: "email" | "phone",
  contactValue: string,
  type: "person" | "service" | "self" = "person"
): RecoveryCustodian => {
  // Validate contact information
  if (contactType === "email" && !validateEmail(contactValue)) {
    throw new Error("Invalid email address");
  }
  if (contactType === "phone" && !validatePhone(contactValue)) {
    throw new Error("Invalid phone number");
  }

  // Check custodian limits
  if (identity.custodians.length >= identity.metadata.preferences.maxCustodians) {
    throw new Error("Maximum number of custodians reached");
  }

  const custodian: RecoveryCustodian = {
    id: generateUniqueId(),
    name,
    type,
    status: "pending",
    contactType,
    contactValue,
    publicKey: "", // Will be generated when custodian accepts
    metadata: {
      verificationMethod: "qr-code",
      invitationExpiresAt: generateExpirationTime(QR_CODE_EXPIRATION_HOURS)
    },
    addedAt: generateTimestamp(),
    canApprove: false, // Will be true after acceptance
    trustLevel: "medium"
  };

  return custodian;
};
```

## 3. QR Code Generation

### Custodian Invitation QR Code
```typescript
import { 
  QRCodeData, 
  CustodianInvitationData,
  generateTimestamp,
  generateExpirationTime,
  QR_CODE_EXPIRATION_HOURS
} from '../types/metadata-standards';

const generateCustodianInvitationQR = (
  identity: IdentityDocument,
  custodian: RecoveryCustodian
): QRCodeData => {
  const invitationData: CustodianInvitationData = {
    invitationId: custodian.id,
    identityId: identity.id,
    identityName: identity.metadata.displayName || identity.metadata.username,
    identityUsername: identity.metadata.username,
    custodianName: custodian.name,
    custodianType: custodian.type,
    contactType: custodian.contactType,
    contactValue: custodian.contactValue,
    deepLinkUrl: `identity-protocol://custodian-invitation?data=${btoa(JSON.stringify(invitationData))}`,
    qrCodeDataURL: "" // Will be generated by QR library
  };

  const qrData: QRCodeData = {
    type: "custodian-invitation",
    version: "1.0",
    timestamp: generateTimestamp(),
    expiresAt: generateExpirationTime(QR_CODE_EXPIRATION_HOURS),
    data: invitationData,
    signature: "" // Will be added for cryptographic verification
  };

  return qrData;
};
```

## 4. Device Syncing

### Device Pairing Process
```typescript
import { 
  SyncedDevice, 
  DeviceSyncData,
  generateTimestamp,
  generateUniqueId,
  DEVICE_SYNC_EXPIRATION_HOURS
} from '../types/metadata-standards';

const addDevice = (
  identity: IdentityDocument,
  deviceName: string,
  deviceType: "mobile" | "desktop" | "tablet" | "other"
): SyncedDevice => {
  const device: SyncedDevice = {
    id: generateUniqueId(),
    name: deviceName,
    type: deviceType,
    lastSync: generateTimestamp(),
    status: "active",
    isPrimary: identity.deviceSync.devices.length === 0, // First device is primary
    deviceFingerprint: generateDeviceFingerprint(),
    syncKey: generateSyncKey(),
    pairedAt: generateTimestamp(),
    lastSeen: generateTimestamp()
  };

  return device;
};

const generateDeviceQR = (
  identity: IdentityDocument,
  device: SyncedDevice
): QRCodeData => {
  const syncData: DeviceSyncData = {
    deviceId: device.id,
    deviceName: device.name,
    deviceType: device.type,
    syncKey: device.syncKey,
    identityId: identity.id,
    deviceFingerprint: device.deviceFingerprint,
    expiresAt: generateExpirationTime(DEVICE_SYNC_EXPIRATION_HOURS),
    qrCodeDataURL: ""
  };

  return {
    type: "device-sync",
    version: "1.0",
    timestamp: generateTimestamp(),
    expiresAt: generateExpirationTime(DEVICE_SYNC_EXPIRATION_HOURS),
    data: syncData
  };
};
```

## 5. Recovery System

### Recovery Request Creation
```typescript
import { 
  RecoveryRequest, 
  generateTimestamp,
  generateUniqueId,
  generateExpirationTime
} from '../types/metadata-standards';

const initiateRecovery = (
  identity: IdentityDocument,
  claimantContactType: "email" | "phone",
  claimantContactValue: string
): RecoveryRequest => {
  const activeCustodians = identity.custodians.filter(c => c.status === "active");
  
  if (activeCustodians.length < identity.recoveryConfig.threshold) {
    throw new Error("Insufficient active custodians for recovery");
  }

  const request: RecoveryRequest = {
    id: generateUniqueId(),
    requestingDid: identity.id,
    requestingUser: identity.metadata.username,
    timestamp: generateTimestamp(),
    status: "pending",
    approvals: [],
    denials: [],
    claimantContactType,
    claimantContactValue,
    expiresAt: generateExpirationTime(72), // 72 hours
    requiredApprovals: identity.recoveryConfig.threshold,
    currentApprovals: 0
  };

  return request;
};
```

## 6. IPFS Integration

### Uploading to IPFS
```typescript
import { 
  serializeForIPFS, 
  createIPFSCID,
  validateIdentityDocument 
} from '../types/metadata-standards';

const uploadIdentityToIPFS = async (identity: IdentityDocument): Promise<string> => {
  // Validate the identity document
  if (!validateIdentityDocument(identity)) {
    throw new Error("Invalid identity document");
  }

  // Serialize for IPFS
  const serialized = serializeForIPFS(identity);
  
  // Upload to IPFS (implementation depends on IPFS client)
  const cid = await createIPFSCID(identity);
  
  return cid;
};

const downloadIdentityFromIPFS = async (cid: string): Promise<IdentityDocument> => {
  // Download from IPFS (implementation depends on IPFS client)
  const response = await fetch(`https://ipfs.io/ipfs/${cid}`);
  const data = await response.text();
  
  // Deserialize
  const identity = JSON.parse(data);
  
  // Validate
  if (!validateIdentityDocument(identity)) {
    throw new Error("Invalid identity document from IPFS");
  }
  
  return identity;
};
```

## 7. Deep Link Handling

### Processing Deep Links
```typescript
import { 
  DeepLinkData, 
  CustodianInvitationData,
  DeviceSyncData,
  RecoveryRequestData,
  isExpired
} from '../types/metadata-standards';

const processDeepLink = (url: string): DeepLinkData | null => {
  try {
    const urlObj = new URL(url);
    
    if (urlObj.protocol !== "identity-protocol:") {
      return null;
    }

    const action = urlObj.hostname;
    const dataParam = urlObj.searchParams.get("data");
    const signature = urlObj.searchParams.get("signature");
    const expires = urlObj.searchParams.get("expires");

    if (!dataParam || !expires) {
      throw new Error("Missing required parameters");
    }

    // Check expiration
    if (isExpired(expires)) {
      throw new Error("Deep link has expired");
    }

    // Decode data
    const data = JSON.parse(atob(dataParam));

    const deepLinkData: DeepLinkData = {
      protocol: "identity-protocol",
      action: action as any,
      data,
      signature: signature || undefined,
      expiresAt: expires
    };

    return deepLinkData;
  } catch (error) {
    console.error("Failed to process deep link:", error);
    return null;
  }
};
```

## 8. Validation and Error Handling

### Comprehensive Validation
```typescript
import { 
  ValidationError, 
  ProcessingError,
  ERROR_CODES,
  validateCustodianInvitation,
  validateQRCodeData
} from '../types/metadata-standards';

const validateCustodianData = (custodian: any): ValidationError[] => {
  const errors: ValidationError[] = [];

  if (!custodian.name || custodian.name.trim().length === 0) {
    errors.push({
      field: "name",
      message: "Custodian name is required",
      code: ERROR_CODES.INVALID_CUSTODIAN_DATA,
      suggestion: "Please provide a valid name"
    });
  }

  if (!custodian.contactValue || custodian.contactValue.trim().length === 0) {
    errors.push({
      field: "contactValue",
      message: "Contact information is required",
      code: ERROR_CODES.INVALID_CONTACT_INFO,
      suggestion: "Please provide a valid email or phone number"
    });
  }

  if (!["email", "phone"].includes(custodian.contactType)) {
    errors.push({
      field: "contactType",
      message: "Invalid contact type",
      code: ERROR_CODES.INVALID_CONTACT_INFO,
      suggestion: "Contact type must be 'email' or 'phone'"
    });
  }

  return errors;
};

const handleProcessingError = (error: ProcessingError): void => {
  switch (error.type) {
    case "validation":
      console.error("Validation error:", error.message);
      // Show user-friendly error message
      break;
    case "serialization":
      console.error("Serialization error:", error.message);
      // Retry or show error
      break;
    case "network":
      console.error("Network error:", error.message);
      // Retry with exponential backoff
      break;
    case "crypto":
      console.error("Cryptographic error:", error.message);
      // Show security error
      break;
  }
};
```

## 9. Privacy and Security

### Privacy Settings Management
```typescript
import { 
  PrivacySharingSettings, 
  GlobalPrivacySettings,
  ThirdPartyAccess
} from '../types/metadata-standards';

const createPrivacySettings = (identityId: string): PrivacySharingSettings => {
  const globalSettings: GlobalPrivacySettings = {
    allowAnalytics: false,
    allowMarketing: false,
    allowThirdPartySharing: false,
    dataRetentionDays: 30,
    encryptMetadata: true,
    requireConsent: true
  };

  return {
    identityId,
    thirdParties: {},
    globalSettings
  };
};

const grantThirdPartyAccess = (
  privacySettings: PrivacySharingSettings,
  partyId: string,
  partyName: string,
  permissions: string[],
  expiresInDays: number = 30
): ThirdPartyAccess => {
  const access: ThirdPartyAccess = {
    name: partyName,
    permissions,
    dataShared: [],
    lastAccess: generateTimestamp(),
    expiresAt: generateExpirationTime(expiresInDays * 24),
    isActive: true
  };

  privacySettings.thirdParties[partyId] = access;
  
  return access;
};
```

## 10. Migration and Version Control

### Version Migration
```typescript
import { 
  needsMigration, 
  migrateV1_0_to_V1_1,
  PROTOCOL_VERSION
} from '../types/metadata-standards';

const migrateIdentityDocument = (identity: any): IdentityDocument => {
  const currentVersion = identity["@context"]?.split("/").pop() || "1.0";
  
  if (needsMigration(currentVersion, "1.1")) {
    console.log(`Migrating identity from v${currentVersion} to v1.1`);
    return migrateV1_0_to_V1_1(identity);
  }
  
  return identity;
};

const checkForUpdates = async (): Promise<void> => {
  // Check for protocol updates
  const response = await fetch("https://identity-protocol.com/version");
  const latestVersion = await response.text();
  
  if (needsMigration(PROTOCOL_VERSION, latestVersion)) {
    console.log(`Protocol update available: ${PROTOCOL_VERSION} â†’ ${latestVersion}`);
    // Prompt user to update
  }
};
```

## 11. Best Practices

### Implementation Checklist
- [ ] **Always validate** data before processing
- [ ] **Use ISO 8601** timestamps consistently
- [ ] **Encrypt sensitive data** before IPFS storage
- [ ] **Include signatures** for cryptographic verification
- [ ] **Set expiration times** for all temporary data
- [ ] **Handle errors gracefully** with user-friendly messages
- [ ] **Test serialization** across different platforms
- [ ] **Document all fields** for developer reference
- [ ] **Implement proper logging** for debugging
- [ ] **Use type guards** for runtime type checking

### Performance Considerations
- **Lazy loading**: Only load metadata when needed
- **Caching**: Cache frequently accessed data locally
- **Compression**: Compress large metadata before IPFS upload
- **Batch operations**: Group related operations for efficiency
- **Background sync**: Sync data in background when possible

### Security Considerations
- **Encrypt all sensitive data** before storage
- **Validate all inputs** to prevent injection attacks
- **Use cryptographic signatures** for data integrity
- **Implement rate limiting** for API calls
- **Regular security audits** of the codebase
- **Secure key management** for cryptographic operations

This implementation guide provides a solid foundation for building applications using the Identity Protocol metadata standards. 