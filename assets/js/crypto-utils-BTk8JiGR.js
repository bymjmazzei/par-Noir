var t=Object.defineProperty,e=(e,r,i)=>((e,r,i)=>r in e?t(e,r,{enumerable:!0,configurable:!0,writable:!0,value:i}):e[r]=i)(e,"symbol"!=typeof r?r+"":r,i),r=(t,e,r)=>new Promise((i,n)=>{var a=t=>{try{o(r.next(t))}catch(e){n(e)}},s=t=>{try{o(r.throw(t))}catch(e){n(e)}},o=t=>t.done?i(t.value):Promise.resolve(t.value).then(a,s);o((r=r.apply(t,e)).next())});class i{static generateDID(){return r(this,null,function*(){try{const t=yield this.generateKeyPair(),e=this.DID_PREFIX+(yield this.generateDIDIdentifier(t.publicKey));return{publicKey:t.publicKey,privateKey:t.privateKey,did:e}}catch(t){throw new Error(`Failed to generate DID: ${t}`)}})}static generateKeyPair(){return r(this,null,function*(){try{const t=yield window.crypto.subtle.generateKey({name:"RSA-OAEP",modulusLength:2048,publicExponent:new Uint8Array([1,0,1]),hash:"SHA-256"},!0,["encrypt","decrypt"]),e=yield window.crypto.subtle.exportKey("spki",t.publicKey),r=yield window.crypto.subtle.exportKey("pkcs8",t.privateKey);return{publicKey:this.arrayBufferToBase64(e),privateKey:this.arrayBufferToBase64(r)}}catch(t){throw new Error(`Failed to generate key pair: ${t}`)}})}static createIdentity(t,e,i,n,a){return r(this,null,function*(){try{const r=yield this.generateDID(),s=yield this.generateRecoveryKeySet(r.did,5),o={id:r.did,username:t,nickname:e,email:"",phone:"",recoveryEmail:n||"",recoveryPhone:a||"",profilePicture:"/branding/Par-Noir-Icon-White.png",createdAt:(new Date).toISOString(),status:"active",custodiansRequired:!0,custodiansSetup:!1,recoveryKeys:s},c=yield this.encrypt(JSON.stringify(o),i);return{publicKey:r.publicKey,encryptedData:c.encrypted,iv:c.iv,salt:c.salt}}catch(r){throw new Error(`Failed to create identity: ${r}`)}})}static authenticateIdentity(t,e,i){return r(this,null,function*(){try{const r=yield this.decrypt({encrypted:t.encryptedData,iv:t.iv,salt:t.salt},e),n=JSON.parse(r);if(i&&n.username!==i)throw new Error("Authentication failed: username mismatch");const a=yield this.generateAuthToken(n.id,n.username);return{id:n.id,pnName:n.pnName,nickname:n.nickname||n.pnName,accessToken:a,expiresIn:this.TOKEN_EXPIRY,authenticatedAt:(new Date).toISOString(),publicKey:t.publicKey}}catch(r){throw new Error(`Authentication failed: ${r}`)}})}static verifyAuthToken(t,e){return r(this,null,function*(){try{const r=t.split(".");if(3!==r.length)return!1;const i=JSON.parse(atob(r[1])),n=Math.floor(Date.now()/1e3);return i.did===e&&i.exp>n}catch(r){return!1}})}static generateRecoveryKey(t,e){return r(this,null,function*(){try{const r={identityId:t,purpose:e,timestamp:Date.now(),random:crypto.getRandomValues(new Uint8Array(32))},i=JSON.stringify(r),n=(new TextEncoder).encode(i),a=yield crypto.subtle.digest("SHA-256",n);return`recovery-${Array.from(new Uint8Array(a)).map(t=>t.toString(16).padStart(2,"0")).join("").substring(0,32)}`}catch(r){throw new Error(`Failed to generate recovery key: ${r}`)}})}static generateRecoveryKeySet(t,e=5){return r(this,null,function*(){try{const t=[],r=["personal","legal","insurance","will","emergency"];for(let i=0;i<e;i++){const e=crypto.getRandomValues(new Uint8Array(16)),n=Array.from(e).map(t=>t.toString(16).padStart(2,"0")).join(""),a=`recovery-${r[i]||`backup-${i+1}`}-${n}`;t.push(a)}return t}catch(t){throw new Error(`Failed to generate recovery key set: ${t}`)}})}static hashPasscode(t,e){return r(this,null,function*(){try{const r=new TextEncoder,i=r.encode(t),n=r.encode(e),a=yield crypto.subtle.importKey("raw",i,"PBKDF2",!1,["deriveBits"]),s=yield crypto.subtle.deriveBits({name:"PBKDF2",salt:n,iterations:1e5,hash:"SHA-256"},a,256);return Array.from(new Uint8Array(s)).map(t=>t.toString(16).padStart(2,"0")).join("")}catch(r){throw new Error(`Failed to hash passcode: ${r}`)}})}static verifyPasscode(t,e,i){return r(this,null,function*(){try{return(yield this.hashPasscode(t,i))===e}catch(r){return!1}})}static encryptData(t,e){return r(this,null,function*(){return yield this.encrypt(t,e)})}static decryptData(t,e){return r(this,null,function*(){return yield this.decrypt(t,e)})}static generateAuthToken(t,e){return r(this,null,function*(){try{const r={alg:"HS256",typ:"JWT"},i={did:t,username:e,iat:Math.floor(Date.now()/1e3),exp:Math.floor(Date.now()/1e3)+this.TOKEN_EXPIRY},n=btoa(JSON.stringify(r)),a=btoa(JSON.stringify(i));return`${n}.${a}.${yield this.generateSignature(n+"."+a)}`}catch(r){throw new Error(`Failed to generate auth token: ${r}`)}})}static encrypt(t,e){return r(this,null,function*(){try{const r=this.generateSalt(),i=yield this.deriveKey(e,r),n=this.generateIV(),a=(new TextEncoder).encode(t),s=yield window.crypto.subtle.encrypt({name:"AES-GCM",iv:n},i,a);return{encrypted:this.arrayBufferToBase64(s),iv:this.arrayBufferToBase64(n),salt:r}}catch(r){throw new Error(`Failed to encrypt data: ${r}`)}})}static legacyDecrypt(t,e){return r(this,null,function*(){try{const i=(new TextEncoder).encode(e),n=this.base64ToArrayBuffer(t.salt),a=this.base64ToArrayBuffer(t.iv),s=this.base64ToArrayBuffer(t.encrypted),o=[{iterations:1e5,hash:"SHA-256"},{iterations:1e4,hash:"SHA-256"},{iterations:1e3,hash:"SHA-256"},{iterations:1e5,hash:"SHA-1"},{iterations:1e4,hash:"SHA-1"},{iterations:1e3,hash:"SHA-1"},{iterations:1e6,hash:"SHA-256"},{iterations:1e6,hash:"SHA-512"}];for(const t of o)try{const e=yield window.crypto.subtle.importKey("raw",i,"PBKDF2",!1,["deriveBits","deriveKey"]),r=yield window.crypto.subtle.deriveKey({name:"PBKDF2",salt:n,iterations:t.iterations,hash:t.hash},e,{name:"AES-GCM",length:256},!1,["encrypt","decrypt"]),o=yield window.crypto.subtle.decrypt({name:"AES-GCM",iv:a},r,s),c=(new TextDecoder).decode(o);return JSON.parse(c),c}catch(r){continue}throw new Error("All decryption parameter combinations failed")}catch(i){throw new Error(`Legacy decryption failed: ${i}`)}})}static decrypt(t,e){return r(this,null,function*(){try{const r=yield this.deriveKey(e,t.salt),i=this.base64ToArrayBuffer(t.iv),n=this.base64ToArrayBuffer(t.encrypted),a=yield window.crypto.subtle.decrypt({name:"AES-GCM",iv:i},r,n);return(new TextDecoder).decode(a)}catch(r){throw new Error(`Failed to decrypt data: ${r}`)}})}static deriveKey(t,e){return r(this,null,function*(){try{const r=(new TextEncoder).encode(t),i=this.base64ToArrayBuffer(e),n=yield window.crypto.subtle.importKey("raw",r,"PBKDF2",!1,["deriveBits","deriveKey"]);return yield window.crypto.subtle.deriveKey({name:"PBKDF2",salt:i,iterations:1e6,hash:"SHA-512"},n,{name:"AES-GCM",length:256},!1,["encrypt","decrypt"])}catch(r){throw new Error(`Failed to derive encryption key: ${r}`)}})}static generateSignature(t){return r(this,null,function*(){try{const e=(new TextEncoder).encode(t),r=yield crypto.subtle.digest("SHA-256",e);return Array.from(new Uint8Array(r)).map(t=>t.toString(16).padStart(2,"0")).join("").substring(0,32)}catch(e){throw new Error(`Failed to generate signature: ${e}`)}})}static generateSalt(){const t=crypto.getRandomValues(new Uint8Array(16));return this.arrayBufferToBase64(t)}static generateIV(){return crypto.getRandomValues(new Uint8Array(12))}static arrayBufferToBase64(t){const e=new Uint8Array(t);let r="";for(let i=0;i<e.byteLength;i++)r+=String.fromCharCode(e[i]);return btoa(r)}static base64ToArrayBuffer(t){try{const e=atob(t),r=new Uint8Array(e.length);for(let t=0;t<e.length;t++)r[t]=e.charCodeAt(t);return r.buffer}catch(e){throw new Error(`Failed to convert base64 to ArrayBuffer: ${e}`)}}static generateDIDIdentifier(t){return r(this,null,function*(){try{const e=(new TextEncoder).encode(t),r=yield crypto.subtle.digest("SHA-256",e);return Array.from(new Uint8Array(r)).map(t=>t.toString(16).padStart(2,"0")).join("").substring(0,16)}catch(e){const t=crypto.getRandomValues(new Uint8Array(8));return Array.from(t).map(t=>t.toString(16).padStart(2,"0")).join("")}})}static decryptIdentity(t,e){return r(this,null,function*(){try{return{id:"mock-did",username:"mock-user",nickname:"Mock User",_publicKey:t}}catch(e){throw new Error(`Failed to decrypt identity: ${e}`)}})}}e(i,"DID_PREFIX","did:key:"),e(i,"TOKEN_EXPIRY",3600);const n=class t{constructor(){e(this,"events",[]),e(this,"rateLimits",new Map),e(this,"threatPatterns",[]),e(this,"sessionId"),this.sessionId=this.generateSessionId(),this.initializeThreatPatterns(),this.startSecurityMonitoring()}static getInstance(){return t.instance||(t.instance=new t),t.instance}initializeThreatPatterns(){this.threatPatterns=[{pattern:"script",severity:"high",description:"Potential XSS attempt"},{pattern:"javascript:",severity:"critical",description:"JavaScript injection attempt"},{pattern:"eval(",severity:"critical",description:"Code injection attempt"},{pattern:"document.cookie",severity:"medium",description:"Cookie manipulation attempt"},{pattern:"localStorage",severity:"low",description:"Storage access attempt"}]}checkForThreats(t,e="user_input"){const r=[];for(const i of this.threatPatterns)if(t.toLowerCase().includes(i.pattern.toLowerCase())){const n={type:"threat_detected",severity:i.severity,message:`${i.description} detected in ${e}`,timestamp:Date.now(),sessionId:this.sessionId,metadata:{pattern:i.pattern,context:e,input:t.substring(0,100)}};r.push(n),this.logSecurityEvent(n)}return r}checkRateLimit(t,e){const r=t.keyGenerator(e),i=Date.now(),n=this.rateLimits.get(r);if(!n||i>n.resetTime)return this.rateLimits.set(r,{count:1,resetTime:i+t.windowMs}),!0;if(n.count>=t.maxRequests){const n={type:"rate_limit_exceeded",severity:"medium",message:`Rate limit exceeded for key: ${r}`,timestamp:i,sessionId:this.sessionId,userId:e,metadata:{key:r,maxRequests:t.maxRequests,windowMs:t.windowMs}};return this.logSecurityEvent(n),!1}return n.count++,!0}validateCertificate(t,e){const r=Math.random()>.1;if(!r){const r={type:"suspicious_activity",severity:"high",message:`Certificate validation failed for domain: ${t}`,timestamp:Date.now(),sessionId:this.sessionId,metadata:{domain:t,expectedFingerprint:e,actualFingerprint:"unknown"}};this.logSecurityEvent(r)}return r}monitorAuthentication(t,e,r){if(!t){const t={type:"authentication_failure",severity:"medium",message:`Authentication failure for user: ${e||"unknown"}`,timestamp:Date.now(),sessionId:this.sessionId,userId:e,metadata:{context:r,attemptCount:this.getAuthenticationAttempts(e)}};this.logSecurityEvent(t)}}validateInput(t,e){if(this.checkForThreats(t,e).length>0)return!1;switch(e){case"email":return this.validateEmail(t);case"phone":return this.validatePhone(t);case"username":return this.validateUsername(t);case"passcode":return this.validatePasscode(t);default:return!0}}sanitizeInput(t){return t.replace(/[<>]/g,"").replace(/javascript:/gi,"").replace(/on\w+=/gi,"").trim()}getSecurityEvents(){return this.events}exportSecurityData(){const t={version:"1.0",timestamp:(new Date).toISOString(),sessionId:this.sessionId,events:this.events,rateLimits:Array.from(this.rateLimits.entries()),threatPatterns:this.threatPatterns};return JSON.stringify(t,null,2)}clearSecurityData(){this.events=[],this.rateLimits.clear()}getSecuritySummary(){const t=this.events.filter(t=>"critical"===t.severity).length,e=this.events.filter(t=>"high"===t.severity).length,r=this.events.filter(t=>"rate_limit_exceeded"===t.type).length,i=this.events.filter(t=>"threat_detected"===t.type).length;return{totalEvents:this.events.length,criticalEvents:t,highSeverityEvents:e,rateLimitViolations:r,threatsDetected:i}}startSecurityMonitoring(){if("undefined"!=typeof window){let t={open:!1};setInterval(()=>{const e=window.outerHeight-window.innerHeight>200||window.outerWidth-window.innerWidth>200;e&&!t.open?(t.open=!0,this.logSecurityEvent({type:"suspicious_activity",severity:"low",message:"Developer tools detected",timestamp:Date.now(),sessionId:this.sessionId})):e||(t.open=!1)},1e3);let e=0,r=0;document.addEventListener("click",()=>{const t=Date.now();t-r<100?(e++,e>10&&(this.logSecurityEvent({type:"suspicious_activity",severity:"medium",message:"Rapid clicking detected - potential automation",timestamp:t,sessionId:this.sessionId}),e=0)):e=0,r=t})}}logSecurityEvent(t){this.events.push(t),this.saveSecurityEvents(),t.severity}getAuthenticationAttempts(t){return this.events.filter(e=>"authentication_failure"===e.type&&e.userId===t).length}validateEmail(t){return/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(t)}validatePhone(t){return/^[+]?[1-9][\d]{0,15}$/.test(t.replace(/[\s\-()]/g,""))}validateUsername(t){return t.length>=3&&t.length<=50&&/^[a-zA-Z0-9_]+$/.test(t)}validatePasscode(t){return t.length>=8&&t.length<=128}generateSessionId(){return`security_${Date.now()}_${Math.random().toString(36).substring(2,15)}`}saveSecurityEvents(){try{localStorage.setItem("security_events",JSON.stringify(this.events))}catch(t){}}};e(n,"instance");const a=n.getInstance();export{i as I,a as s};
