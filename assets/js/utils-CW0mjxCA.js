const __vite__mapDeps=(i,m=__vite__mapDeps,d=(m.f||(m.f=["assets/js/vendor-BERG7lu9.js","assets/js/qr-CUcyLVYE.js"])))=>i.map(i=>d[i]);
var t=Object.defineProperty,e=Object.defineProperties,i=Object.getOwnPropertyDescriptors,n=Object.getOwnPropertySymbols,r=Object.prototype.hasOwnProperty,s=Object.prototype.propertyIsEnumerable,a=(t,e)=>(e=Symbol[t])?e:Symbol.for("Symbol."+t),o=(e,i,n)=>i in e?t(e,i,{enumerable:!0,configurable:!0,writable:!0,value:n}):e[i]=n,c=(t,e)=>{for(var i in e||(e={}))r.call(e,i)&&o(t,i,e[i]);if(n)for(var i of n(e))s.call(e,i)&&o(t,i,e[i]);return t},l=(t,n)=>e(t,i(n)),u=(t,e,i)=>o(t,"symbol"!=typeof e?e+"":e,i),d=(t,e,i)=>new Promise((n,r)=>{var s=t=>{try{o(i.next(t))}catch(e){r(e)}},a=t=>{try{o(i.throw(t))}catch(e){r(e)}},o=t=>t.done?n(t.value):Promise.resolve(t.value).then(s,a);o((i=i.apply(t,e)).next())});import{Q as h}from"./qr-CUcyLVYE.js";import{s as y}from"./storage-utils-D16TCNXA.js";import{_ as g}from"./hooks-BUBt1EqL.js";import{I as p}from"./crypto-utils-BTk8JiGR.js";function m(t){const e=new Date,i=Math.floor((e.getTime()-t.getTime())/1e3);if(i<60)return"just now";const n=Math.floor(i/60);if(n<60)return`${n} minute${n>1?"s":""} ago`;const r=Math.floor(n/60);if(r<24)return`${r} hour${r>1?"s":""} ago`;const s=Math.floor(r/24);if(s<7)return`${s} day${s>1?"s":""} ago`;const a=Math.floor(s/7);if(a<4)return`${a} week${a>1?"s":""} ago`;const o=Math.floor(s/30);if(o<12)return`${o} month${o>1?"s":""} ago`;const c=Math.floor(s/365);return`${c} year${c>1?"s":""} ago`}class f{static generateDevicePairingQR(t){return d(this,null,function*(){try{const e={type:"device-pairing",data:t,timestamp:Date.now(),expiresAt:Date.now()+3e5};e.signature=yield this.generateSignature(e);const i=JSON.stringify(e);return yield h.toDataURL(i,{width:this.QR_SIZE,margin:this.QR_MARGIN,color:{dark:"#000000",light:"#FFFFFF"}})}catch(e){throw new Error(`Failed to generate device pairing QR code: ${e}`)}})}static generateCustodianInvitationQR(t){return d(this,null,function*(){try{const e={type:"custodian-invitation",data:t,timestamp:Date.now(),expiresAt:t.expiresAt};e.signature=yield this.generateSignature(e);const i=JSON.stringify(e);return yield h.toDataURL(i,{width:this.QR_SIZE,margin:this.QR_MARGIN,color:{dark:"#000000",light:"#FFFFFF"}})}catch(e){throw new Error(`Failed to generate custodian invitation QR code: ${e}`)}})}static generateRecoveryKeyQR(t,e){return d(this,null,function*(){try{const i={type:"recovery-key",data:{recoveryKey:t,purpose:e,generatedAt:Date.now()},timestamp:Date.now()};i.signature=yield this.generateSignature(i);const n=JSON.stringify(i);return yield h.toDataURL(n,{width:this.QR_SIZE,margin:this.QR_MARGIN,color:{dark:"#000000",light:"#FFFFFF"}})}catch(i){throw new Error(`Failed to generate recovery key QR code: ${i}`)}})}static parseQRCode(t){return d(this,null,function*(){try{const e=document.createElement("canvas"),i=e.getContext("2d"),n=new Image;return new Promise((r,s)=>{n.onload=()=>d(null,null,function*(){try{e.width=n.width,e.height=n.height,null==i||i.drawImage(n,0,0);const t={type:"device-pairing",data:{deviceId:`device-${Date.now()}`,deviceName:"Mock Device",deviceType:"mobile",syncKey:`sync-${Math.random().toString(36).substring(2)}`,identityId:`did:key:${Math.random().toString(36).substring(2)}`,deviceFingerprint:`fp-${Math.random().toString(36).substring(2)}`},timestamp:Date.now(),expiresAt:Date.now()+3e5,signature:`sig-${Math.random().toString(36).substring(2)}`};r(t)}catch(t){s(new Error(`Failed to parse QR code: ${t}`))}}),n.onerror=()=>s(new Error("Failed to load QR code image")),n.src=t})}catch(e){throw new Error(`Failed to parse QR code: ${e}`)}})}static validateQRCodeData(t){return d(this,null,function*(){try{if(t.expiresAt&&Date.now()>t.expiresAt)return!1;if(t.signature){const e=yield this.generateSignature(t);if(t.signature!==e)return!1}switch(t.type){case"device-pairing":return this.validateDevicePairingData(t.data);case"custodian-invitation":return this.validateCustodianInvitationData(t.data);case"recovery-key":return this.validateRecoveryKeyData(t.data);default:return!1}}catch(e){return!1}})}static generateSignature(t){return d(this,null,function*(){try{const e={type:t.type,data:t.data,timestamp:t.timestamp,expiresAt:t.expiresAt},i=JSON.stringify(e),n=(new TextEncoder).encode(i),r=yield crypto.subtle.digest("SHA-256",n);return Array.from(new Uint8Array(r)).map(t=>t.toString(16).padStart(2,"0")).join("").substring(0,32)}catch(e){throw new Error(`Failed to generate signature: ${e}`)}})}static validateDevicePairingData(t){return t&&"string"==typeof t.deviceId&&"string"==typeof t.deviceName&&"string"==typeof t.deviceType&&"string"==typeof t.syncKey&&"string"==typeof t.identityId&&"string"==typeof t.deviceFingerprint}static validateCustodianInvitationData(t){return t&&"string"==typeof t.invitationId&&"string"==typeof t.invitationCode&&"string"==typeof t.custodianName&&"string"==typeof t.custodianType&&"string"==typeof t.contactType&&"string"==typeof t.contactValue&&"number"==typeof t.expiresAt}static validateRecoveryKeyData(t){return t&&"string"==typeof t.recoveryKey&&"string"==typeof t.purpose&&"number"==typeof t.generatedAt}static generateDeviceFingerprint(){try{const t={userAgent:navigator.userAgent,platform:navigator.platform,language:navigator.language,screenResolution:`${screen.width}x${screen.height}`,timezone:Intl.DateTimeFormat().resolvedOptions().timeZone,timestamp:Date.now()},e=JSON.stringify(t),i=(new TextEncoder).encode(e);return crypto.subtle.digest("SHA-256",i).then(t=>Array.from(new Uint8Array(t)).map(t=>t.toString(16).padStart(2,"0")).join("").substring(0,32)),`fp-${Math.random().toString(36).substring(2)}`}catch(t){return`fp-${Math.random().toString(36).substring(2)}`}}static generateSyncKey(){try{const t=crypto.getRandomValues(new Uint8Array(32));return crypto.subtle.digest("SHA-256",t).then(t=>Array.from(new Uint8Array(t)).map(t=>t.toString(16).padStart(2,"0")).join("").substring(0,32)),`sync-${Math.random().toString(36).substring(2)}`}catch(t){return`sync-${Math.random().toString(36).substring(2)}`}}}u(f,"QR_SIZE",256),u(f,"QR_MARGIN",2);const S=class t{constructor(){u(this,"STORAGE_KEY","simple_identities")}static getInstance(){return t.instance||(t.instance=new t),t.instance}storeIdentity(t){return d(this,null,function*(){try{const e=(yield this.getIdentities()).filter(e=>e.id!==t.id);e.push(t),localStorage.setItem(this.STORAGE_KEY,JSON.stringify(e))}catch(e){throw e}})}getIdentities(){return d(this,null,function*(){try{const t=localStorage.getItem(this.STORAGE_KEY);return t?JSON.parse(t):[]}catch(t){return[]}})}getIdentity(t){return d(this,null,function*(){try{return(yield this.getIdentities()).find(e=>e.id===t)||null}catch(e){return null}})}updateNickname(t,e){return d(this,null,function*(){try{const i=(yield this.getIdentities()).map(i=>i.id===t?l(c({},i),{nickname:e}):i);localStorage.setItem(this.STORAGE_KEY,JSON.stringify(i))}catch(i){throw i}})}updateIdentity(t){return d(this,null,function*(){try{const e=(yield this.getIdentities()).map(e=>e.id===t.id?t:e);localStorage.setItem(this.STORAGE_KEY,JSON.stringify(e))}catch(e){throw e}})}deleteIdentity(t){return d(this,null,function*(){try{const e=(yield this.getIdentities()).filter(e=>e.id!==t);localStorage.setItem(this.STORAGE_KEY,JSON.stringify(e))}catch(e){throw e}})}clearAll(){return d(this,null,function*(){try{localStorage.removeItem(this.STORAGE_KEY)}catch(t){throw t}})}};u(S,"instance");let I=S;class E{static isPWA(){return window.matchMedia("(display-mode: standalone)").matches||!0===window.navigator.standalone}static storeForMigration(t){return d(this,null,function*(){try{const e=yield this.getWebIdentities(),i={id:t.publicKey||"",data:t,createdAt:(new Date).toISOString(),needsMigration:!1};e.push(i),localStorage.setItem(this.WEB_IDENTITIES_KEY,JSON.stringify(e))}catch(e){}})}static getWebIdentities(){try{const t=localStorage.getItem(this.WEB_IDENTITIES_KEY);return t?JSON.parse(t):[]}catch(t){return[]}}static isMigrationNeeded(){return d(this,null,function*(){if(!this.isPWA())return!1;const t=this.getWebIdentities().filter(t=>t.needsMigration);if(0===t.length)return!1;try{const e=yield y.getAllIdentities();if(0===e.length)return!0;const i=new Set(e.map(t=>t.id));return t.some(t=>!i.has(t.id))}catch(e){return!0}})}static getPendingMigrations(){return d(this,null,function*(){if(!this.isPWA())return[];const t=this.getWebIdentities().filter(t=>t.needsMigration&&(t.migrationAttempts||0)<this.MAX_MIGRATION_ATTEMPTS);try{const e=yield y.getAllIdentities(),i=new Set(e.map(t=>t.id));return t.filter(t=>!i.has(t.id))}catch(e){return t}})}static migrateIdentities(t){return d(this,null,function*(){const e={success:!0,migratedCount:0,errors:[],skippedCount:0};if(!this.isPWA())return e.success=!1,e.errors.push("Migration can only be performed in PWA mode"),e;for(const n of t)try{if(!this.validateIdentityData(n.data)){e.errors.push(`Invalid identity data for ${n.id}`),e.skippedCount++;continue}if(yield y.getIdentity(n.id)){this.markAsMigrated(n.id),e.skippedCount++;continue}yield y.saveIdentity(n.data),e.migratedCount++,this.markAsMigrated(n.id)}catch(i){e.errors.push(`Failed to migrate ${n.id}: ${i}`),this.incrementMigrationAttempts(n.id)}return e.success=0===e.errors.length,this.storeMigrationStatus(e),e})}static validateIdentityData(t){return!!(t&&t.publicKey&&t.publicKey&&t.encryptedData&&t.iv&&t.salt)}static markAsMigrated(t){try{const e=this.getWebIdentities(),i=e.findIndex(e=>e.id===t);i>=0&&(e[i].needsMigration=!1,localStorage.setItem(this.WEB_IDENTITIES_KEY,JSON.stringify(e)))}catch(e){}}static incrementMigrationAttempts(t){try{const e=this.getWebIdentities(),i=e.findIndex(e=>e.id===t);i>=0&&(e[i].migrationAttempts=(e[i].migrationAttempts||0)+1,localStorage.setItem(this.WEB_IDENTITIES_KEY,JSON.stringify(e)))}catch(e){}}static storeMigrationStatus(t){var e;try{const i={lastMigration:(new Date).toISOString(),result:t,totalAttempts:(null==(e=this.getMigrationStatus())?void 0:e.totalAttempts)||1};localStorage.setItem(this.MIGRATION_STATUS_KEY,JSON.stringify(i))}catch(i){}}static getMigrationStatus(){try{const t=localStorage.getItem(this.MIGRATION_STATUS_KEY);return t?JSON.parse(t):null}catch(t){return null}}static clearWebStorage(){try{const t=this.getWebIdentities().filter(t=>t.needsMigration);0===t.length?localStorage.removeItem(this.WEB_IDENTITIES_KEY):localStorage.setItem(this.WEB_IDENTITIES_KEY,JSON.stringify(t))}catch(t){}}static resetMigrationStatus(){localStorage.removeItem(this.MIGRATION_STATUS_KEY);const t=this.getWebIdentities();t.forEach(t=>{t.needsMigration=!0,t.migrationAttempts=0}),t.length>0&&localStorage.setItem(this.WEB_IDENTITIES_KEY,JSON.stringify(t))}static getMigrationStats(){const t=this.getWebIdentities();return{totalWebIdentities:t.length,pendingMigrations:t.filter(t=>t.needsMigration).length,completedMigrations:t.filter(t=>!t.needsMigration).length,failedAttempts:t.filter(t=>(t.migrationAttempts||0)>=this.MAX_MIGRATION_ATTEMPTS).length}}}u(E,"WEB_IDENTITIES_KEY","web-identities"),u(E,"MIGRATION_STATUS_KEY","migration-status"),u(E,"MAX_MIGRATION_ATTEMPTS",3);class A{static isAvailable(){return d(this,null,function*(){try{return!!window.PublicKeyCredential&&(yield PublicKeyCredential.isUserVerifyingPlatformAuthenticatorAvailable())}catch(t){return!1}})}static getSupportedTypes(){return d(this,null,function*(){const t=[];try{if(!(yield this.isAvailable()))return t;t.push("platform"),"getClientCapabilities"in navigator.credentials&&t.push("enhanced")}catch(e){}return t})}static registerCredential(t,e){return d(this,null,function*(){try{if(!(yield this.isAvailable()))throw new Error("Biometric authentication not available on this device");const i=new Uint8Array(32);crypto.getRandomValues(i);const n={publicKey:{challenge:i,rp:{name:"Identity Protocol",id:window.location.hostname},user:{id:(new TextEncoder).encode(t),name:e,displayName:e},pubKeyCredParams:[{alg:-7,type:"public-key"},{alg:-257,type:"public-key"}],authenticatorSelection:{authenticatorAttachment:"platform",userVerification:"required",requireResidentKey:!0},timeout:6e4,attestation:"direct"}},r=yield navigator.credentials.create(n);if(!r)throw new Error("Failed to create biometric credential");const s=r.response,a=Array.from(new Uint8Array(r.rawId)).map(t=>t.toString(16).padStart(2,"0")).join(""),o={id:`biometric_${Date.now()}`,identityId:t,credentialId:a,publicKey:Array.from(new Uint8Array(s.getPublicKey()||new ArrayBuffer(0))).map(t=>t.toString(16).padStart(2,"0")).join(""),createdAt:(new Date).toISOString(),lastUsed:(new Date).toISOString(),deviceName:yield this.getDeviceName(),authenticatorType:"platform"};return yield this.storeCredential(o),o}catch(i){if("NotSupportedError"===i.name)throw new Error("Biometric authentication not supported on this device");if("SecurityError"===i.name)throw new Error("Biometric registration blocked by security policy");if("NotAllowedError"===i.name)throw new Error("Biometric registration cancelled by user");if("InvalidStateError"===i.name)throw new Error("Biometric credential already exists for this account");throw i}})}static authenticate(t){return d(this,null,function*(){try{if(!(yield this.isAvailable()))return{success:!1,error:"Biometric authentication not available",fallbackToPasscode:!0};const e=yield this.getCredentials(t);if(0===e.length)return{success:!1,error:"No biometric credentials found for this identity",fallbackToPasscode:!0};const i=new Uint8Array(32);crypto.getRandomValues(i);const n={publicKey:{challenge:i,allowCredentials:e.map(t=>{var e;return{id:new Uint8Array((null==(e=t.credentialId.match(/.{2}/g))?void 0:e.map(t=>parseInt(t,16)))||[]),type:"public-key",transports:["internal"]}}),userVerification:"required",timeout:6e4}},r=yield navigator.credentials.get(n);if(!r)return{success:!1,error:"Biometric authentication failed",fallbackToPasscode:!0};const s=Array.from(new Uint8Array(r.rawId)).map(t=>t.toString(16).padStart(2,"0")).join(""),a=e.find(t=>t.credentialId===s);return a?(a.lastUsed=(new Date).toISOString(),yield this.updateCredential(a),{success:!0,credentialId:a.credentialId}):{success:!1,error:"Credential not recognized",fallbackToPasscode:!0}}catch(e){return"NotAllowedError"===e.name?{success:!1,error:"Biometric authentication cancelled",fallbackToPasscode:!0}:"SecurityError"===e.name?{success:!1,error:"Biometric authentication blocked by security policy",fallbackToPasscode:!0}:"UnknownError"===e.name?{success:!1,error:"Biometric sensor not available or failed",fallbackToPasscode:!0}:{success:!1,error:e.message||"Biometric authentication failed",fallbackToPasscode:!0}}})}static getCredentials(t){return d(this,null,function*(){try{const e=localStorage.getItem(this.CREDENTIAL_STORAGE_KEY);return e?JSON.parse(e).filter(e=>e.identityId===t):[]}catch(e){return[]}})}static storeCredential(t){return d(this,null,function*(){try{const e=localStorage.getItem(this.CREDENTIAL_STORAGE_KEY),i=e?JSON.parse(e):[];i.push(t),localStorage.setItem(this.CREDENTIAL_STORAGE_KEY,JSON.stringify(i))}catch(e){throw e}})}static updateCredential(t){return d(this,null,function*(){try{const e=localStorage.getItem(this.CREDENTIAL_STORAGE_KEY);if(!e)return;const i=JSON.parse(e),n=i.findIndex(e=>e.id===t.id);-1!==n&&(i[n]=t,localStorage.setItem(this.CREDENTIAL_STORAGE_KEY,JSON.stringify(i)))}catch(e){}})}static removeCredentials(t){return d(this,null,function*(){try{const e=localStorage.getItem(this.CREDENTIAL_STORAGE_KEY);if(!e)return;const i=JSON.parse(e).filter(e=>e.identityId!==t);localStorage.setItem(this.CREDENTIAL_STORAGE_KEY,JSON.stringify(i))}catch(e){}})}static removeCredential(t){return d(this,null,function*(){try{const e=localStorage.getItem(this.CREDENTIAL_STORAGE_KEY);if(!e)return;const i=JSON.parse(e).filter(e=>e.id!==t);localStorage.setItem(this.CREDENTIAL_STORAGE_KEY,JSON.stringify(i))}catch(e){}})}static getDeviceName(){return d(this,null,function*(){try{const t=navigator.userAgent;return t.includes("iPhone")?"iPhone":t.includes("iPad")?"iPad":t.includes("Android")?"Android Device":t.includes("Mac")?"Mac":t.includes("Windows")?"Windows PC":t.includes("Linux")?"Linux Device":"Unknown Device"}catch(t){return"Device"}})}static getCapabilityInfo(){return d(this,null,function*(){const t=yield this.isAvailable(),e=yield this.getSupportedTypes(),i=yield this.getDeviceName(),n=[];return t&&(n.push("Platform Authenticator"),e.includes("platform")&&n.push("Built-in Biometrics")),{available:t,types:e,deviceName:i,supportedFeatures:n}})}}u(A,"CREDENTIAL_STORAGE_KEY","biometric-credentials");const w=class t{constructor(t={}){u(this,"config"),u(this,"isConnected",!1),u(this,"syncQueue",[]),u(this,"syncInterval",null),this.config=c({apiEndpoint:"https://api.identityprotocol.com/sync",syncInterval:3e4},t)}static getInstance(){return t.instance||(t.instance=new t),t.instance}initialize(){return d(this,null,function*(){try{if(!(yield this.testConnection()))throw new Error("Failed to connect to cloud sync service");this.isConnected=!0,this.startPeriodicSync(),yield this.processSyncQueue()}catch(t){this.isConnected=!1}})}testConnection(){return d(this,null,function*(){try{const{orbitCloudAPI:t}=yield g(()=>d(null,null,function*(){const{orbitCloudAPI:t}=yield Promise.resolve().then(()=>Y);return{orbitCloudAPI:t}}),void 0);return(yield t.healthCheck())?{success:!0}:{success:!1,error:"Connection failed"}}catch(t){return{success:!1,error:t instanceof Error?t.message:"Unknown error"}}})}storeUpdate(t){return d(this,null,function*(){const e=l(c({},t),{updatedAt:(new Date).toISOString()});this.isConnected?yield this.sendToCloud(e):this.syncQueue.push(e)})}storeNicknameUpdate(t){return d(this,null,function*(){const e={type:"nickname",identityId:t.identityId,publicKey:t.publicKey,data:{oldNickname:t.oldNickname,newNickname:t.newNickname},updatedByDeviceId:t.updatedByDeviceId,signature:t.signature};yield this.storeUpdate(e)})}getUpdates(t){return d(this,null,function*(){try{const{orbitCloudAPI:e}=yield g(()=>d(null,null,function*(){const{orbitCloudAPI:t}=yield Promise.resolve().then(()=>Y);return{orbitCloudAPI:t}}),void 0);return yield e.getUpdates(t)}catch(e){return[]}})}getNicknameUpdates(t){return d(this,null,function*(){try{return(yield this.getUpdates(t)).filter(t=>"nickname"===t.type).map(t=>({identityId:t.identityId,publicKey:t.publicKey,oldNickname:t.data.oldNickname,newNickname:t.data.newNickname,updatedByDeviceId:t.updatedByDeviceId,updatedAt:t.updatedAt,signature:t.signature}))}catch(e){return[]}})}sendToCloud(t){return d(this,null,function*(){try{const{orbitCloudAPI:e}=yield g(()=>d(null,null,function*(){const{orbitCloudAPI:t}=yield Promise.resolve().then(()=>Y);return{orbitCloudAPI:t}}),void 0);yield e.storeUpdate(t)}catch(e){this.syncQueue.push(t)}})}processSyncQueue(){return d(this,null,function*(){if(0===this.syncQueue.length)return;const t=[...this.syncQueue];this.syncQueue=[];for(const i of t)try{yield this.sendToCloud(i)}catch(e){this.syncQueue.push(i)}})}startPeriodicSync(){this.syncInterval&&clearInterval(this.syncInterval),this.syncInterval=window.setInterval(()=>{this.processSyncQueue().catch(()=>{})},this.config.syncInterval)}stopPeriodicSync(){this.syncInterval&&(clearInterval(this.syncInterval),this.syncInterval=null)}getConnectionStatus(){return this.isConnected}getQueueLength(){return this.syncQueue.length}disconnect(){this.isConnected=!1,this.stopPeriodicSync()}};u(w,"instance");const v=w.getInstance();class C{static encryptMetadata(t,e,i,n){return d(this,null,function*(){try{const e=JSON.stringify(t),r=yield p.encryptData(e,i);return{encryptedData:r.encrypted,iv:r.iv,salt:r.salt,version:"1.0.0",identityId:n,updatedAt:(new Date).toISOString()}}catch(e){throw new Error("Metadata encryption failed")}})}static decryptMetadata(t,e,i){return d(this,null,function*(){try{const e={encrypted:t.encryptedData,iv:t.iv,salt:t.salt},n=yield p.decryptData(e,i);return JSON.parse(n)}catch(e){throw new Error("Metadata decryption failed - check your credentials")}})}static updateMetadataField(t,e,i,n,r){return d(this,null,function*(){try{const s=yield this.decryptMetadata(t,e,i),a=l(c({},s),{[n]:r});return yield this.encryptMetadata(a,e,i,t.identityId)}catch(s){throw new Error("Metadata update failed")}})}static verifyMetadata(t,e,i){return d(this,null,function*(){try{return yield this.decryptMetadata(t,e,i),!0}catch(n){return!1}})}static createInitialMetadata(t,e,i){return d(this,arguments,function*(t,e,i,n={}){const r={nickname:n.nickname||t,profilePicture:n.profilePicture,custodians:n.custodians||[],recoveryKeys:n.recoveryKeys||[],syncedDevices:n.syncedDevices||[],privacySettings:n.privacySettings||{}};return yield this.encryptMetadata(r,t,e,i)})}}class _{static storeMetadata(t,e){return d(this,null,function*(){try{const i=this.getStoredMetadata();i[t]=e,localStorage.setItem(this.STORAGE_KEY,JSON.stringify(i))}catch(i){throw new Error("Failed to store metadata")}})}static getMetadata(t){return d(this,null,function*(){try{return this.getStoredMetadata()[t]||null}catch(e){return null}})}static storeMetadataInCloud(t,e){return d(this,null,function*(){try{const i=this.getCloudMetadata();i[t]=e,localStorage.setItem(this.CLOUD_SYNC_KEY,JSON.stringify(i))}catch(i){}})}static getMetadataFromCloud(t){return d(this,null,function*(){try{return this.getCloudMetadata()[t]||null}catch(e){return null}})}static updateMetadataField(t,e,i,n,r){return d(this,null,function*(){try{const a=yield this.getMetadata(t);if(a){const o=yield C.updateMetadataField(a,e,i,n,r);if(yield this.storeMetadata(t,o),navigator.onLine)try{yield this.storeMetadataInCloud(t,o)}catch(s){this.markForCloudSync(t,o)}else this.markForCloudSync(t,o)}else{const a=yield C.createInitialMetadata(e,i,t,{[n]:r});if(yield this.storeMetadata(t,a),navigator.onLine)try{yield this.storeMetadataInCloud(t,a)}catch(s){this.markForCloudSync(t,a)}else this.markForCloudSync(t,a)}}catch(s){throw new Error("Failed to update metadata")}})}static applyMetadataToIdentity(t,e,i){return d(this,null,function*(){try{const n=t.id||t.publicKey,r=yield this.getMetadata(n);if(r){const n=yield C.decryptMetadata(r,e,i);return c(c({},t),n)}return t}catch(n){return t}})}static markForCloudSync(t,e){try{const i=this.getPendingSync();i[t]={metadata:e,timestamp:(new Date).toISOString(),synced:!1},localStorage.setItem(this.PENDING_SYNC_KEY,JSON.stringify(i))}catch(i){}}static getPendingSync(){try{const t=localStorage.getItem(this.PENDING_SYNC_KEY);return t?JSON.parse(t):{}}catch(t){return{}}}static syncPendingToCloud(){return d(this,null,function*(){try{const e=this.getPendingSync();let i=0,n=0;for(const[r,s]of Object.entries(e))if(!s.synced)try{yield this.storeMetadataInCloud(r,s.metadata),s.synced=!0,i++}catch(t){n++}return localStorage.setItem(this.PENDING_SYNC_KEY,JSON.stringify(e)),{synced:i,failed:n}}catch(t){return{synced:0,failed:0}}})}static syncMetadataFromCloud(t){return d(this,null,function*(){try{const e=yield this.getMetadataFromCloud(t);e&&(yield this.storeMetadata(t,e))}catch(e){}})}static getStoredMetadata(){try{const t=localStorage.getItem(this.STORAGE_KEY);return t?JSON.parse(t):{}}catch(t){return{}}}static getCloudMetadata(){try{const t=localStorage.getItem(this.CLOUD_SYNC_KEY);return t?JSON.parse(t):{}}catch(t){return{}}}static clearMetadata(t){return d(this,null,function*(){try{const e=this.getStoredMetadata();delete e[t],localStorage.setItem(this.STORAGE_KEY,JSON.stringify(e));const i=this.getCloudMetadata();delete i[t],localStorage.setItem(this.CLOUD_SYNC_KEY,JSON.stringify(i))}catch(e){}})}static verifyMetadataIntegrity(t,e,i){return d(this,null,function*(){try{const n=yield this.getMetadata(t);return!n||(yield C.verifyMetadata(n,e,i))}catch(n){return!1}})}}u(_,"STORAGE_KEY","secure_metadata"),u(_,"CLOUD_SYNC_KEY","cloud_metadata_sync"),u(_,"PENDING_SYNC_KEY","pending_metadata_sync");const P=10,b=5;class N{static monitorAPICallFrequency(t){return d(this,null,function*(){const e=Date.now()-36e5;return this.apiCallLog.filter(i=>i.identityHash===t&&i.timestamp>e).length})}static logAPICall(t,e,i){const n={timestamp:Date.now(),endpoint:e,method:i,identityHash:t};this.apiCallLog.push(n),this.apiCallLog.length>1e4&&(this.apiCallLog=this.apiCallLog.slice(-1e4))}static checkEnterpriseFeatureAccess(t){return d(this,null,function*(){const e=Date.now()-864e5;return this.enterpriseFeatureLog.filter(i=>i.identityHash===t&&i.accessTimestamp>e&&i.requiresCommercialLicense).length>0})}static logEnterpriseFeatureAccess(t,e,i,n=!0){const r={featureId:e,featureName:i,accessTimestamp:Date.now(),identityHash:t,requiresCommercialLicense:n};this.enterpriseFeatureLog.push(r),this.enterpriseFeatureLog.length>1e3&&(this.enterpriseFeatureLog=this.enterpriseFeatureLog.slice(-1e3))}static analyzeScaleIndicators(t){return d(this,null,function*(){const e=this.scaleIndicatorsLog.get(t.identityHash||"unknown");if(e)return e;const i=this.extractScaleIndicators(t);if(i){const e={userCount:i.userCount||0,integrationCount:i.integrationCount||0,whiteLabelUsage:i.whiteLabelUsage||!1,multiTenantUsage:i.multiTenantUsage||!1,lastUpdated:Date.now(),identityHash:t.identityHash||"unknown"};return this.scaleIndicatorsLog.set(e.identityHash,e),e}return null})}static extractScaleIndicators(t){const e={};return t.userManagement&&(e.userCount=t.userManagement.totalUsers||0),t.integrations&&(e.integrationCount=t.integrations.count||0),t.whiteLabel&&(e.whiteLabelUsage=t.whiteLabel.enabled||!1),t.multiTenant&&(e.multiTenantUsage=t.multiTenant.enabled||!1),e}static storeScaleIndicators(t){this.scaleIndicatorsLog.set(t.identityHash,t)}static analyzeUsagePattern(t,e){return d(this,null,function*(){const i=yield this.monitorAPICallFrequency(t),n=yield this.checkEnterpriseFeatureAccess(t),r=e?yield this.analyzeScaleIndicators(e):null,s=i>100||n||r&&(r.userCount>P||r.integrationCount>b||r.whiteLabelUsage||r.multiTenantUsage),a=this.usagePatterns.get(t),o=Date.now();let c=null==a?void 0:a.commercialUsageFirstDetected,l=null==a?void 0:a.gracePeriodExpires,u=!1;s&&!(null==a?void 0:a.commercialUsageFirstDetected)&&(c=o,l=o+2592e5),l&&o<l&&(u=!0);const d={apiCallFrequency:i,enterpriseFeatureAccess:n,scaleIndicators:r,isCommercial:s||!1,lastChecked:o,commercialUsageFirstDetected:c,gracePeriodExpires:l,gracePeriodActive:u};return this.usagePatterns.set(t,d),d})}static getUsagePattern(t){return this.usagePatterns.get(t)||null}static isGracePeriodActive(t){const e=this.usagePatterns.get(t);return e&&e.gracePeriodActive||!1}static shouldEnforceRestrictions(t){const e=this.usagePatterns.get(t);return!!e&&e.isCommercial&&!e.gracePeriodActive}static getGracePeriodStatus(t){const e=this.usagePatterns.get(t);if(!e||!e.isCommercial)return{isActive:!1,expiresAt:null,daysRemaining:0,shouldEnforce:!1};const i=Date.now(),n=e.gracePeriodExpires?new Date(e.gracePeriodExpires):null,r=e.gracePeriodExpires?Math.max(0,Math.ceil((e.gracePeriodExpires-i)/864e5)):0;return{isActive:e.gracePeriodActive||!1,expiresAt:n,daysRemaining:r,shouldEnforce:!e.gracePeriodActive}}static resetGracePeriod(t){const e=this.usagePatterns.get(t);e&&(e.commercialUsageFirstDetected=void 0,e.gracePeriodExpires=void 0,e.gracePeriodActive=!1,this.usagePatterns.set(t,e))}static clearDetectionLogs(){this.apiCallLog=[],this.enterpriseFeatureLog=[],this.scaleIndicatorsLog.clear(),this.usagePatterns.clear()}static getDetectionStats(){return{totalAPICalls:this.apiCallLog.length,totalEnterpriseAccesses:this.enterpriseFeatureLog.length,totalScaleIndicators:this.scaleIndicatorsLog.size,totalUsagePatterns:this.usagePatterns.size}}static generateLicenseProof(t,e){return d(this,null,function*(){const e={licenseKey:t.licenseKey,identityHash:t.identityHash,licenseType:t.type,isValid:this.isLicenseValid(t),issuedDate:t.issuedAt,isCommercial:t.isCommercial},i=yield this.generateRealZKP(e),n=yield this.signProof(e);return{proof:i,publicInputs:{licenseType:t.type,isValid:this.isLicenseValid(t),issuedDate:t.issuedAt,identityHash:t.identityHash,isCommercial:t.isCommercial},signature:n}})}static verifyLicenseProof(t){return d(this,null,function*(){try{const e=yield this.verifyRealZKP(t.proof,t),i=yield this.verifySignature(t.proof,t.signature);return e&&i}catch(e){return!1}})}static isLicenseValid(t){return"active"===t.status&&("free"===t.type||"perpetual"===t.type||("Never"===t.expiresAt||new Date<new Date(t.expiresAt)))}static generateReceipt(t,e){return{receiptId:`RCP_${Date.now()}_${t.identityHash.substring(0,8)}`,licenseType:t.type,amount:this.getLicensePrice(t.type),currency:"USD",paymentMethod:e.method,purchaseDate:t.issuedAt,identityHash:t.identityHash,transactionHash:e.transactionHash,isCommercial:t.isCommercial}}static generateFreeLicense(t,e){return d(this,null,function*(){const e={licenseKey:`FREE_${t.substring(0,16)}_${Date.now()}`,type:"free",identityHash:t,issuedAt:(new Date).toISOString(),expiresAt:"Never",status:"active",isCommercial:!1};return yield this.storeLicense(e),e})}static generateCommercialLicense(t,e,i){return d(this,null,function*(){const i=`COM_${t.toUpperCase()}_${e.substring(0,16)}_${Date.now()}`,n=new Date,r="perpetual"===t?"Never":new Date(n.getFullYear()+1,n.getMonth(),n.getDate()).toISOString(),s={licenseKey:i,type:t,identityHash:e,issuedAt:n.toISOString(),expiresAt:r,status:"active",isCommercial:!0};return yield this.storeLicense(s),s})}static findLicenseByIdentityHash(t){return d(this,null,function*(){const e=localStorage.getItem(`license_${t}`);return e?JSON.parse(e):null})}static storeLicense(t){return d(this,null,function*(){localStorage.setItem(`license_${t.identityHash}`,JSON.stringify(t))})}static transferLicense(t,e){return d(this,null,function*(){const i=yield this.findLicenseByIdentityHash(t);if(!i)return null;const n=l(c({},i),{licenseKey:`TRANSFERRED_${i.licenseKey}`,identityHash:e,transferredFrom:t,transferDate:(new Date).toISOString(),originalIssueDate:i.originalIssueDate||i.issuedAt});return yield this.storeLicense(n),yield this.invalidateLicense(i.licenseKey),n})}static invalidateLicense(t){return d(this,null,function*(){const e=Object.keys(localStorage);for(const i of e)if(i.startsWith("license_")){const e=JSON.parse(localStorage.getItem(i)||"{}");if(e.licenseKey===t){e.status="expired",localStorage.setItem(i,JSON.stringify(e));break}}})}static getLicensePrice(t){switch(t){case"free":default:return 0;case"perpetual":return 3999;case"annual":return 1499}}static generateRealZKP(t){return d(this,null,function*(){try{const e=yield crypto.subtle.generateKey({name:"ECDSA",namedCurve:"P-384"},!0,["sign","verify"]),i=JSON.stringify({licenseHash:t.licenseKey,identityHash:t.identityHash,isCommercial:t.isCommercial,timestamp:Date.now(),nonce:crypto.randomUUID()}),n=(new TextEncoder).encode(i),r=yield crypto.subtle.sign({name:"ECDSA",hash:"SHA-384"},e.privateKey,n),s=new Uint8Array(r),a=btoa(String.fromCharCode(...s));return(Date.now(),{schnorrProof:{response:a,publicKey:yield crypto.subtle.exportKey("spki",e.publicKey),message:i,curve:"P-384",algorithm:"ECDSA-SHA384"}}).schnorrProof.response}catch(e){const i=JSON.stringify(t),n=(new TextEncoder).encode(i),r=yield crypto.subtle.digest("SHA-512",n);return Array.from(new Uint8Array(r)).map(t=>t.toString(16).padStart(2,"0")).join("")}})}static verifyRealZKP(t,e){return d(this,null,function*(){try{const i=JSON.parse(t),n=JSON.stringify({licenseHash:e.licenseKey,identityHash:e.identityHash,isCommercial:e.isCommercial,timestamp:i.timestamp,nonce:i.nonce}),r=(new TextEncoder).encode(n),s=Uint8Array.from(atob(i.publicKey),t=>t.charCodeAt(0)),a=yield crypto.subtle.importKey("spki",s,{name:"ECDSA",namedCurve:"P-384"},!1,["verify"]),o=Uint8Array.from(atob(i.signature),t=>t.charCodeAt(0));return yield crypto.subtle.verify({name:"ECDSA",hash:"SHA-384"},a,o,r)}catch(i){return!1}})}static signProof(t){return d(this,null,function*(){try{const e=yield crypto.subtle.generateKey({name:"ECDSA",namedCurve:"P-384"},!0,["sign","verify"]),i=JSON.stringify(t),n=(new TextEncoder).encode(i),r=yield crypto.subtle.sign({name:"ECDSA",hash:"SHA-384"},e.privateKey,n),s=new Uint8Array(r),a=btoa(String.fromCharCode(...s)),o=yield crypto.subtle.exportKey("spki",e.publicKey),c=btoa(String.fromCharCode(...new Uint8Array(o)));return JSON.stringify({signature:a,publicKey:c,algorithm:"ECDSA-P384-SHA384",timestamp:Date.now()})}catch(e){const i=JSON.stringify(t),n=(new TextEncoder).encode(i),r=yield crypto.subtle.digest("SHA-512",n);return Array.from(new Uint8Array(r)).map(t=>t.toString(16).padStart(2,"0")).join("")}})}static verifySignature(t,e){return d(this,null,function*(){try{const i=JSON.parse(e),n=JSON.stringify(t),r=(new TextEncoder).encode(n),s=Uint8Array.from(atob(i.publicKey),t=>t.charCodeAt(0)),a=yield crypto.subtle.importKey("spki",s,{name:"ECDSA",namedCurve:"P-384"},!1,["verify"]),o=Uint8Array.from(atob(i.signature),t=>t.charCodeAt(0));return yield crypto.subtle.verify({name:"ECDSA",hash:"SHA-384"},a,o,r)}catch(i){return!1}})}static hasLicense(t){return d(this,null,function*(){const e=yield this.findLicenseByIdentityHash(t);return null!==e&&this.isLicenseValid(e)})}static hasCommercialLicense(t){return d(this,null,function*(){const e=yield this.findLicenseByIdentityHash(t);return null!==e&&e.isCommercial&&this.isLicenseValid(e)})}static getLicenseStatus(t){return d(this,null,function*(){const e=yield this.findLicenseByIdentityHash(t);return e?{hasLicense:this.isLicenseValid(e),isCommercial:e.isCommercial,licenseType:e.type,status:e.status,expiresAt:e.expiresAt}:{hasLicense:!1,isCommercial:!1,licenseType:"none",status:"none",expiresAt:"N/A"}})}}u(N,"apiCallLog",[]),u(N,"enterpriseFeatureLog",[]),u(N,"scaleIndicatorsLog",new Map),u(N,"usagePatterns",new Map);class T{static validateDID(t){const e=[],i=[];return t&&"string"==typeof t?(t.length>100&&e.push("DID length exceeds maximum limit of 100 characters"),this.DID_PATTERN.test(t)||e.push("Invalid DID format. Must be in format: did:key:<base64-encoded-key>"),this.containsXSS(t)&&e.push("DID contains potentially malicious content"),this.containsSQLInjection(t)&&e.push("DID contains potentially malicious SQL patterns"),{isValid:0===e.length,errors:e,warnings:i,sanitizedValue:this.sanitizeString(t)}):(e.push("DID must be a non-empty string"),{isValid:!1,errors:e,warnings:i})}static validatePNName(t){const e=[],i=[];return t&&"string"==typeof t?(t.length<3&&e.push("pN Name must be at least 3 characters long"),t.length>20&&e.push("pN Name must be no more than 20 characters long"),this.USERNAME_PATTERN.test(t)||e.push("pN Name can only contain letters, numbers, and hyphens"),this.RESERVED_USERNAMES.includes(t.toLowerCase())&&e.push("pN Name is reserved and cannot be used"),this.containsXSS(t)&&e.push("pN Name contains potentially malicious content"),this.containsSQLInjection(t)&&e.push("pN Name contains potentially malicious SQL patterns"),{isValid:0===e.length,errors:e,warnings:i,sanitizedValue:this.sanitizeString(t)}):(e.push("pN Name must be a non-empty string"),{isValid:!1,errors:e,warnings:i})}static validatePasscode(t){const e=[],i=[];return t&&"string"==typeof t?(t.length<12&&e.push("Passcode must be at least 12 characters long"),t.length>128&&e.push("Passcode must be no more than 128 characters long"),/[A-Z]/.test(t)||e.push("Passcode must contain at least one uppercase letter"),/[a-z]/.test(t)||e.push("Passcode must contain at least one lowercase letter"),/[0-9]/.test(t)||e.push("Passcode must contain at least one number"),/[^A-Za-z0-9]/.test(t)||e.push("Passcode must contain at least one special character"),["password","123456","qwerty","admin","letmein","welcome","monkey","dragon","master","football","baseball","shadow"].some(e=>t.toLowerCase().includes(e))&&i.push("Passcode contains common weak patterns"),["qwerty","asdfgh","zxcvbn","1234567890"].some(e=>t.toLowerCase().includes(e))&&i.push("Passcode contains keyboard patterns"),/(.)\1{3,}/.test(t)&&i.push("Passcode contains repeated characters"),{isValid:0===e.length,errors:e,warnings:i,sanitizedValue:t}):(e.push("Passcode must be a non-empty string"),{isValid:!1,errors:e,warnings:i})}static validateEmail(t){const e=[],i=[];return t&&"string"==typeof t?(t.length>254&&e.push("Email length exceeds maximum limit of 254 characters"),this.EMAIL_PATTERN.test(t)||e.push("Invalid email format"),this.containsXSS(t)&&e.push("Email contains potentially malicious content"),{isValid:0===e.length,errors:e,warnings:i,sanitizedValue:this.sanitizeString(t)}):(e.push("Email must be a non-empty string"),{isValid:!1,errors:e,warnings:i})}static validatePhone(t){const e=[],i=[];return t&&"string"==typeof t?(t.length>20&&e.push("Phone number length exceeds maximum limit of 20 characters"),this.PHONE_PATTERN.test(t)||e.push("Invalid phone number format. Must be in international format: +1234567890"),{isValid:0===e.length,errors:e,warnings:i,sanitizedValue:this.sanitizeString(t)}):(e.push("Phone number must be a non-empty string"),{isValid:!1,errors:e,warnings:i})}static validatePublicKey(t){const e=[],i=[];return t&&"string"==typeof t?(t.length<100&&e.push("Public key appears to be too short"),t.length>1e3&&e.push("Public key appears to be too long"),this.PUBLIC_KEY_PATTERN.test(t)||e.push("Invalid public key format"),{isValid:0===e.length,errors:e,warnings:i,sanitizedValue:t}):(e.push("Public key must be a non-empty string"),{isValid:!1,errors:e,warnings:i})}static validateSignature(t){const e=[],i=[];return t&&"string"==typeof t?(t.length<50&&e.push("Signature appears to be too short"),t.length>500&&e.push("Signature appears to be too long"),this.SIGNATURE_PATTERN.test(t)||e.push("Invalid signature format"),{isValid:0===e.length,errors:e,warnings:i,sanitizedValue:t}):(e.push("Signature must be a non-empty string"),{isValid:!1,errors:e,warnings:i})}static validateChallenge(t){const e=[],i=[];return t&&"string"==typeof t?(t.length<20&&e.push("Challenge appears to be too short"),t.length>200&&e.push("Challenge appears to be too long"),this.CHALLENGE_PATTERN.test(t)||e.push("Invalid challenge format"),{isValid:0===e.length,errors:e,warnings:i,sanitizedValue:t}):(e.push("Challenge must be a non-empty string"),{isValid:!1,errors:e,warnings:i})}static validateDisplayName(t){const e=[],i=[];return t&&"string"==typeof t?(t.length<1&&e.push("Display name must be at least 1 character long"),t.length>50&&e.push("Display name must be no more than 50 characters long"),this.containsXSS(t)&&e.push("Display name contains potentially malicious content"),this.containsSQLInjection(t)&&e.push("Display name contains potentially malicious SQL patterns"),{isValid:0===e.length,errors:e,warnings:i,sanitizedValue:this.sanitizeString(t)}):(e.push("Display name must be a non-empty string"),{isValid:!1,errors:e,warnings:i})}static validateNickname(t){const e=[],i=[];return t&&"string"==typeof t?(t.length<1&&e.push("Nickname must be at least 1 character long"),t.length>30&&e.push("Nickname must be no more than 30 characters long"),this.containsXSS(t)&&e.push("Nickname contains potentially malicious content"),this.containsSQLInjection(t)&&e.push("Nickname contains potentially malicious SQL patterns"),{isValid:0===e.length,errors:e,warnings:i,sanitizedValue:this.sanitizeString(t)}):(e.push("Nickname must be a non-empty string"),{isValid:!1,errors:e,warnings:i})}static containsXSS(t){return this.XSS_PATTERNS.some(e=>e.test(t))}static containsSQLInjection(t){return this.SQL_INJECTION_PATTERNS.some(e=>e.test(t))}static containsPathTraversal(t){return this.PATH_TRAVERSAL_PATTERNS.some(e=>e.test(t))}static sanitizeString(t){let e=t.replace(/\0/g,"");return e=e.replace(/[\x00-\x08\x0B\x0C\x0E-\x1F\x7F]/g,""),e=e.trim(),e}static validateFileUpload(t){const e=[],i=[];if(!t)return e.push("File is required"),{isValid:!1,errors:e,warnings:i};t.size>10485760&&e.push("File size exceeds maximum limit of 10MB");const n=t.name.toLowerCase().substring(t.name.lastIndexOf("."));return["application/json","text/plain","application/octet-stream"].includes(t.type)||[".pn",".id",".json",".identity"].includes(n)||e.push("Invalid file type. Only Par-Noir identity files (.pn, .id, .json, .identity) are allowed"),t.name.length>255&&e.push("Filename is too long"),this.containsPathTraversal(t.name)&&e.push("Filename contains potentially malicious patterns"),{isValid:0===e.length,errors:e,warnings:i}}static validateJSON(t){const e=[],i=[];if(!t)return e.push("Data is required"),{isValid:!1,errors:e,warnings:i};("object"!=typeof t||Array.isArray(t))&&e.push("Data must be a valid object");try{JSON.stringify(t)}catch(n){e.push("Data contains circular references")}return JSON.stringify(t).length>1048576&&e.push("Data size exceeds maximum limit of 1MB"),{isValid:0===e.length,errors:e,warnings:i}}static validateIdentityCreation(t){const e=[],i=[],n=this.validatePNName(t.pnName);n.isValid||e.push(...n.errors),i.push(...n.warnings);const r=this.validateNickname(t.nickname);r.isValid||e.push(...r.errors),i.push(...r.warnings);const s=this.validatePasscode(t.passcode);if(s.isValid||e.push(...s.errors),i.push(...s.warnings),t.email){const n=this.validateEmail(t.email);n.isValid||e.push(...n.errors),i.push(...n.warnings)}if(t.phone){const n=this.validatePhone(t.phone);n.isValid||e.push(...n.errors),i.push(...n.warnings)}return{isValid:0===e.length,errors:e,warnings:i}}}u(T,"DID_PATTERN",/^did:key:[a-zA-Z0-9]{32,}$/),u(T,"USERNAME_PATTERN",/^[a-zA-Z0-9-]{3,20}$/),u(T,"RESERVED_USERNAMES",["admin","root","system","test","guest","anonymous","null","undefined","api","oauth","auth","login","logout","register","signup","signin"]),u(T,"EMAIL_PATTERN",/^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$/),u(T,"PHONE_PATTERN",/^\+[1-9]\d{1,14}$/),u(T,"PUBLIC_KEY_PATTERN",/^[A-Za-z0-9+/]{100,}$/),u(T,"SIGNATURE_PATTERN",/^[A-Za-z0-9+/]{50,}$/),u(T,"CHALLENGE_PATTERN",/^[A-Za-z0-9+/]{20,}$/),u(T,"XSS_PATTERNS",[/<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi,/javascript:/gi,/vbscript:/gi,/onload\s*=/gi,/onerror\s*=/gi,/onclick\s*=/gi,/onmouseover\s*=/gi,/<iframe\b[^>]*>/gi,/<object\b[^>]*>/gi,/<embed\b[^>]*>/gi]),u(T,"SQL_INJECTION_PATTERNS",[/(\b(union|select|insert|update|delete|drop|create|alter|exec|execute)\b)/gi,/(--|\/\*|\*\/|;)/g,/(\b(and|or)\b\s+\d+\s*=\s*\d+)/gi,/(\b(and|or)\b\s+['"]\w+['"]\s*=\s*['"]\w+['"])/gi]),u(T,"PATH_TRAVERSAL_PATTERNS",[/\.\.\//g,/\.\.\\/g,/\/etc\/passwd/gi,/\/proc\/version/gi,/\/sys\/class\/net/gi]);const R=new class{constructor(t){u(this,"config"),u(this,"ipfsClient",null),u(this,"isDevelopment"),u(this,"mockFiles",new Map),this.config=c({host:"ipfs.infura.io",port:parseInt("5001"),protocol:"https",gateway:"https://ipfs.io/ipfs/",apiKey:void 0,timeout:parseInt("30000")},t),this.isDevelopment=!0,this.isDevelopment||this.initializeRealIPFS()}initializeRealIPFS(){return d(this,null,function*(){try{try{const{create:t}=yield g(()=>d(null,null,function*(){const{create:t}=yield import("./vendor-BERG7lu9.js").then(t=>t.i);return{create:t}}),__vite__mapDeps([0,1]));this.ipfsClient=t({host:this.config.host,port:this.config.port,protocol:this.config.protocol,headers:this.config.apiKey?{Authorization:`Bearer ${this.config.apiKey}`}:void 0})}catch(t){this.isDevelopment=!0}}catch(e){this.isDevelopment=!0}})}upload(t){return d(this,null,function*(){try{return this.isDevelopment||!this.ipfsClient?this.mockUpload(t):yield this.realUpload(t)}catch(e){const t=e instanceof Error?e.message:"Unknown error";throw new Error(`Failed to upload to IPFS: ${t}`)}})}mockUpload(t){return d(this,null,function*(){const e=JSON.stringify(t,null,2),i=`bafybeig${Buffer.from(e).toString("hex").substring(0,44)}`;return this.mockFiles.set(i,t),yield new Promise(t=>setTimeout(t,100)),i})}realUpload(t){return d(this,null,function*(){if(!this.ipfsClient)throw new Error("IPFS client not initialized");const e=JSON.stringify(t,null,2);return(yield this.ipfsClient.add(e)).cid.toString()})}download(t){return d(this,null,function*(){try{return this.isDevelopment||!this.ipfsClient?this.mockDownload(t):yield this.realDownload(t)}catch(e){const t=e instanceof Error?e.message:"Unknown error";throw new Error(`Failed to download from IPFS: ${t}`)}})}mockDownload(t){return d(this,null,function*(){const e=this.mockFiles.get(t);if(e)return e;const i={message:"Mock IPFS data",cid:t,timestamp:(new Date).toISOString()};return yield new Promise(t=>setTimeout(t,100)),i})}realDownload(t){return d(this,null,function*(){if(!this.ipfsClient)throw new Error("IPFS client not initialized");const e=[];try{for(var i,n,r,s=((t,e,i)=>(e=t[a("asyncIterator")])?e.call(t):(t=t[a("iterator")](),e={},(i=(i,n)=>(n=t[i])&&(e[i]=e=>new Promise((i,r,s)=>(e=n.call(t,e),s=e.done,Promise.resolve(e.value).then(t=>i({value:t,done:s}),r)))))("next"),i("return"),e))(this.ipfsClient.cat(t));i=!(n=yield s.next()).done;i=!1){const t=n.value;e.push(t)}}catch(n){r=[n]}finally{try{i&&(n=s.return)&&(yield n.call(s))}finally{if(r)throw r[0]}}const o=Buffer.concat(e).toString();return JSON.parse(o)})}uploadFile(t){return d(this,null,function*(){try{const e=yield t.arrayBuffer(),i=Buffer.from(e);let n;if(this.isDevelopment||!this.ipfsClient)n=yield this.mockUpload(i);else{if(!this.ipfsClient)throw new Error("IPFS client not initialized");n=(yield this.ipfsClient.add(i)).cid.toString()}return{cid:n,name:t.name,size:t.size,type:t.type,uploadedAt:(new Date).toISOString()}}catch(e){const t=e instanceof Error?e.message:"Unknown error";throw new Error(`Failed to upload file to IPFS: ${t}`)}})}testConnection(){return d(this,null,function*(){try{if(this.isDevelopment)return yield new Promise(t=>setTimeout(t,50)),!0;return(yield fetch(`${this.config.gateway}QmYwAPJzv5CZsnA625s3Xf2nemtYgPpHdWEz79ojWnPbdG`,{method:"HEAD",signal:AbortSignal.timeout(this.config.timeout||3e4)})).ok}catch(t){return!1}})}getGatewayURL(t){return`${this.config.gateway}${t}`}getMode(){return this.isDevelopment?"development":"production"}getStats(){return d(this,null,function*(){const t=yield this.testConnection();return{mode:this.getMode(),filesCount:this.mockFiles.size,isConnected:t}})}};var O={};const D={API_KEY:O.COINBASE_COMMERCE_API_KEY||"your-coinbase-api-key-here",WEBHOOK_SECRET:O.COINBASE_WEBHOOK_SECRET||"your-webhook-secret-here",SUPPORTED_CURRENCIES:["BTC","ETH","XRP","USDT"],PAYMENT_SETTINGS:{TIMEOUT_MINUTES:30,CONFIRMATION_BLOCKS:{BTC:3,ETH:12,XRP:4,USDT:12,DEFAULT:6},PRICE_TOLERANCE:.05},WEBHOOK_EVENTS:["charge:confirmed","charge:failed","charge:expired","charge:created"]},M=Object.freeze(Object.defineProperty({__proto__:null,COINBASE_CONFIG:D},Symbol.toStringTag,{value:"Module"}));class k{static createCheckoutDirect(t){return d(this,null,function*(){var e;try{const i=yield fetch(`${this.API_BASE}/checkouts`,{method:"POST",headers:{"Content-Type":"application/json","X-CC-Api-Key":this.API_KEY,"X-CC-Version":"2018-03-22"},body:JSON.stringify(t)});if(!i.ok){const t=yield i.json().catch(()=>({error:{message:i.statusText}}));throw new Error(`Coinbase API Error: ${(null==(e=t.error)?void 0:e.message)||i.statusText}`)}const n=(yield i.json()).data;return!n.hosted_url&&n.hosted_urls&&(n.hosted_url=n.hosted_urls.redirect),n.hosted_url||(n.hosted_url=`https://commerce.coinbase.com/checkout/${n.id}`),n}catch(i){throw i}})}static createCheckoutViaProxy(t){return d(this,null,function*(){try{const e="http://localhost:3001",i=yield fetch(`${e}/api/coinbase/create-checkout`,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify(t)});if(!i.ok){const t=yield i.json();throw new Error(`Server Error: ${t.error||i.statusText}`)}return(yield i.json()).checkout}catch(e){throw e}})}static createDirectCheckoutURL(t){return'data:text/html,<html><body style="font-family: Arial, sans-serif; padding: 20px; text-align: center;"><h2>ðŸš§ Development Mode</h2><p>The Coinbase Commerce server needs to be running.</p><p>Please run: <code>cd server && npm start</code></p><p>Then try again.</p></body></html>'}static createCheckout(t){return d(this,null,function*(){try{return yield this.createCheckoutDirect(t)}catch(e){try{return yield this.createCheckoutViaProxy(t)}catch(i){const e=this.createDirectCheckoutURL(t);return{id:`checkout_${Date.now()}`,hosted_url:e,name:t.name,description:t.description,pricing_type:t.pricing_type,local_price:t.local_price,metadata:t.metadata}}}})}static validateCheckoutData(t){var e,i,n,r;return!!(t.name&&t.description&&"fixed_price"===t.pricing_type&&(null==(e=t.local_price)?void 0:e.amount)&&(null==(i=t.local_price)?void 0:i.currency)&&(null==(n=t.metadata)?void 0:n.licenseType)&&(null==(r=t.metadata)?void 0:r.identityHash))}}u(k,"API_BASE","https://api.commerce.coinbase.com"),u(k,"API_KEY",D.API_KEY);var L={};const U=new class{constructor(){u(this,"results",[])}runAllTests(){return d(this,null,function*(){return this.results=[],yield this.testEnvironmentVariables(),yield this.testCoinbase(),yield this.testIPFS(),this.results})}testIPFS(){return d(this,null,function*(){try{const t=void 0,e=void 0;if(!t)return void this.results.push({service:"Pinata IPFS",status:"skipped",message:"Pinata API key not configured",details:{reason:"Environment variable not set"}});this.results.push({service:"Pinata IPFS",status:"success",message:"IPFS service configured correctly",details:{hasApiKey:!!t,gatewayUrl:e||"https://gateway.pinata.cloud",readyForUpload:!0}})}catch(t){this.results.push({service:"Pinata IPFS",status:"error",message:`IPFS service failed: ${t instanceof Error?t.message:"Unknown error"}`,details:{error:t}})}})}testCoinbase(){return d(this,null,function*(){try{const t=void 0;if(!t)return void this.results.push({service:"Coinbase Commerce",status:"skipped",message:"Coinbase API key not configured",details:{reason:"Environment variable not set"}});const{COINBASE_CONFIG:e}=yield g(()=>d(this,null,function*(){const{COINBASE_CONFIG:t}=yield Promise.resolve().then(()=>M);return{COINBASE_CONFIG:t}}),void 0);this.results.push({service:"Coinbase Commerce",status:"success",message:"Coinbase Commerce configured correctly",details:{hasApiKey:!!t,supportedCurrencies:e.SUPPORTED_CURRENCIES,webhookEvents:e.WEBHOOK_EVENTS}})}catch(t){this.results.push({service:"Coinbase Commerce",status:"error",message:`Coinbase service failed: ${t instanceof Error?t.message:"Unknown error"}`,details:{error:t}})}})}testEnvironmentVariables(){return d(this,null,function*(){try{const t=["REACT_APP_TWILIO_ACCOUNT_SID","REACT_APP_TWILIO_AUTH_TOKEN","REACT_APP_TWILIO_FROM_NUMBER","REACT_APP_SENDGRID_API_KEY","REACT_APP_FROM_EMAIL","REACT_APP_FROM_NAME","REACT_APP_PINATA_API_KEY","REACT_APP_IPFS_GATEWAY_URL","REACT_APP_COINBASE_COMMERCE_API_KEY"],e=[],i=[];t.forEach(t=>{const n=L[t];n&&""!==n?i.push(t):e.push(t)}),this.results.push({service:"Environment Variables",status:0===e.length?"success":"error",message:0===e.length?"All required environment variables are set":`Missing ${e.length} environment variables`,details:{present:i.length,missing:e,total:t.length}}),e.length}catch(t){this.results.push({service:"Environment Variables",status:"error",message:`Environment test failed: ${t instanceof Error?t.message:"Unknown error"}`,details:{error:t}})}})}getSummary(){return{total:this.results.length,passed:this.results.filter(t=>"success"===t.status).length,failed:this.results.filter(t=>"error"===t.status).length,skipped:this.results.filter(t=>"skipped"===t.status).length}}printResults(){this.results.forEach(t=>{"success"===t.status||t.status,t.details}),this.getSummary().failed}};window.runIntegrationTests=()=>d(null,null,function*(){try{const t=yield U.runAllTests();window.testResults=t,U.printResults()}catch(t){}});var K=(t=>(t.STORAGE_ERROR="STORAGE_ERROR",t.ENCRYPTION_ERROR="ENCRYPTION_ERROR",t.VALIDATION_ERROR="VALIDATION_ERROR",t.NETWORK_ERROR="NETWORK_ERROR",t.AUTHENTICATION_ERROR="AUTHENTICATION_ERROR",t.NOT_FOUND_ERROR="NOT_FOUND_ERROR",t.PERMISSION_DENIED="PERMISSION_DENIED",t.INVALID_INPUT="INVALID_INPUT",t.TIMEOUT_ERROR="TIMEOUT_ERROR",t.UNKNOWN_ERROR="UNKNOWN_ERROR",t))(K||{});class F extends Error{constructor(t,e="UNKNOWN_ERROR",i){super(t),u(this,"code"),u(this,"details"),this.name="IdentityError",this.code=e,this.details=i}}var x={};const z=new class{constructor(t={}){u(this,"config"),u(this,"isInitialized",!1),u(this,"orbitDBInstance",null),u(this,"database",null),u(this,"ipfsInstance",null),this.config=c({ipfsConfig:{url:x.REACT_APP_IPFS_URL||"https://ipfs.infura.io:5001",gatewayUrl:"https://ipfs.io",projectId:"",projectSecret:x.REACT_APP_IPFS_PROJECT_SECRET||""},databaseName:"pn-metadata",encryptionEnabled:!0,syncEnabled:!0},t)}initialize(){return d(this,null,function*(){try{yield this.initializeIPFS(),yield this.initializeOrbitDB(),this.isInitialized=!0}catch(t){throw new F("Failed to initialize OrbitDB service",K.STORAGE_ERROR,t)}})}initializeIPFS(){return d(this,null,function*(){try{const{create:t}=yield g(()=>d(null,null,function*(){const{create:t}=yield import("./vendor-BERG7lu9.js").then(t=>t.i);return{create:t}}),__vite__mapDeps([0,1]));this.ipfsInstance=t({url:this.config.ipfsConfig.url,headers:this.config.ipfsConfig.projectId?{Authorization:`Bearer ${this.config.ipfsConfig.projectId}`}:void 0})}catch(t){throw new F("Failed to initialize IPFS connection",K.STORAGE_ERROR,t)}})}initializeOrbitDB(){return d(this,null,function*(){})}storePNMetadata(t){return d(this,null,function*(){this.isInitialized||(yield this.initialize());try{const e=this.config.encryptionEnabled?yield this.encryptMetadata(t):t,i=yield this.database.put(e);return{success:!0,data:l(c({},t),{cid:i.toString(),updatedAt:(new Date).toISOString()}),cid:i.toString()}}catch(e){return{success:!1,error:e instanceof Error?e.message:"Unknown error"}}})}getPNMetadata(t){return d(this,null,function*(){this.isInitialized||(yield this.initialize());try{const e=yield this.database.query(e=>e.pnId===t);if(0===e.length)return{success:!1,error:"Metadata not found"};const i=e[0];return{success:!0,data:this.config.encryptionEnabled?yield this.decryptMetadata(i):i}}catch(e){return{success:!1,error:e instanceof Error?e.message:"Unknown error"}}})}updatePNMetadata(t,e){return d(this,null,function*(){var i;this.isInitialized||(yield this.initialize());try{const n=yield this.getPNMetadata(t);if(!n.success)return n;const r=l(c(c({},n.data),e),{updatedAt:(new Date).toISOString(),version:((null==(i=n.data)?void 0:i.version)||0)+1});return yield this.storePNMetadata(r)}catch(n){return{success:!1,error:n instanceof Error?n.message:"Unknown error"}}})}storeUpdate(t){return d(this,null,function*(){this.isInitialized||(yield this.initialize());try{const e={pnId:t.pnId,[t.type]:t.data,timestamp:t.timestamp,signature:t.signature};return{success:!0,data:e,cid:(yield this.database.put(e)).toString()}}catch(e){return{success:!1,error:e instanceof Error?e.message:"Unknown error"}}})}getUpdates(t){return d(this,null,function*(){this.isInitialized||(yield this.initialize());try{return{success:!0,data:yield this.database.query(e=>e.pnId===t)}}catch(e){return{success:!1,error:e instanceof Error?e.message:"Unknown error"}}})}healthCheck(){return d(this,null,function*(){try{return this.isInitialized?(yield this.ipfsInstance.id(),this.database.address.toString(),{success:!0}):{success:!1,error:"Service not initialized"}}catch(t){return{success:!1,error:t instanceof Error?t.message:"Unknown error"}}})}encryptMetadata(t){return d(this,null,function*(){return t})}decryptMetadata(t){return d(this,null,function*(){return t})}getStats(){return d(this,null,function*(){if(!this.isInitialized)throw new Error("Service not initialized");return{totalDocuments:this.database.all.length,databaseAddress:this.database.address.toString(),lastSync:(new Date).toISOString()}})}sync(){return d(this,null,function*(){if(!this.isInitialized)throw new Error("Service not initialized");yield this.database.sync()})}close(){return d(this,null,function*(){this.database&&(yield this.database.close()),this.orbitDBInstance&&(yield this.orbitDBInstance.disconnect())})}},V=class t{static getInstance(){return t.instance||(t.instance=new t),t.instance}healthCheck(){return d(this,null,function*(){try{return(yield z.healthCheck()).success}catch(t){return!1}})}storeUpdate(t){return d(this,null,function*(){const e={type:t.type,pnId:t.identityId,data:t.data,timestamp:t.updatedAt,signature:t.signature},i=yield z.storeUpdate(e);if(!i.success)throw new Error(`Failed to store update: ${i.error}`)})}getUpdates(t){return d(this,null,function*(){try{const e=yield z.getUpdates(t);return e.success?e.data.map(t=>({type:t.type,identityId:t.pnId,publicKey:t.publicKey||"",data:t.data,updatedByDeviceId:t.updatedByDeviceId||"",updatedAt:t.timestamp,signature:t.signature})):[]}catch(e){return[]}})}storeNicknameUpdate(t){return d(this,null,function*(){const e={type:"nickname",pnId:t.identityId,data:{oldNickname:t.oldNickname,newNickname:t.newNickname},timestamp:t.updatedAt,signature:t.signature},i=yield z.storeUpdate(e);if(!i.success)throw new Error(`Failed to store nickname update: ${i.error}`)})}};u(V,"instance");let $=V;const B=$.getInstance(),Y=Object.freeze(Object.defineProperty({__proto__:null,OrbitCloudAPI:$,orbitCloudAPI:B},Symbol.toStringTag,{value:"Module"}));export{A as B,k as C,T as I,N as L,E as M,f as Q,I as S,_ as a,v as c,m as g,R as i};
